<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/lihe/MyLeetcode</id><title>RSS feed of lihe's MyLeetcode</title><updated>2025-12-25T14:51:57.734527+00:00</updated><link href="https://github.com/lihe/MyLeetcode"/><link href="https://raw.githubusercontent.com/lihe/MyLeetcode/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/lihe/MyLeetcode/issues/1</id><title>LeetCode 206 反转链表</title><updated>2025-12-25T14:51:58.078863+00:00</updated><content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a></p>
<h2><strong>一、题目回顾</strong></h2>
<p><strong>问题</strong></p>
<p>给定单链表头节点 head，反转链表并返回反转后的头节点。</p>
<hr />
<h2><strong>二、两种标准解法概览</strong></h2>
<h3><strong>1️⃣ 迭代法（首插法 / 三指针）</strong></h3>
<pre><code class="language-python">class Solution:
    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        pre = None
        cur = head
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre
</code></pre>
<p><strong>核心思想</strong></p>
<p>不断把当前节点 cur 插到新链表头部 pre 前。</p>
<hr />
<h3><strong>2️⃣ 递归法（重点）</strong></h3>
<pre><code class="language-python">class Solution:
    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        if head is None or head.next is None:
            return head
        
        rev_head = self.reverseList(head.next)
        tail = head.next
        tail.next = head
        head.next = None
        return rev_head
</code></pre>
<hr />
<h2><strong>三、递归反转链表的本质理解</strong></h2>
<h3><strong>递归一句话定义</strong></h3>
<blockquote>
<p><strong>我不反转整个链表，只负责把“当前节点”接到“已经反转好的后半段”后面。</strong></p>
</blockquote>
<hr />
<h2><strong>四、递归执行的完整过程（示例）</strong></h2>
<p>链表：</p>
<pre><code>1 → 2 → 3 → None
</code></pre>
<p>调用：</p>
<pre><code>reverseList(1)
</code></pre>
<hr />
<h3><strong>1️⃣ 递归下潜（只做调用，不反转）</strong></h3>
<pre><code>reverse(1)
 → reverse(2)
   → reverse(3)
</code></pre>
<p>在 head = 3 时触发 base case：</p>
<pre><code>if head.next is None:
    return head
</code></pre>
<p>返回节点 3</p>
<hr />
<h3><strong>2️⃣ 回溯阶段（真正发生反转）</strong></h3>
<h4><strong>回到head = 2</strong></h4>
<pre><code>tail = head.next      # 3
tail.next = head      # 3 → 2
head.next = None      # 2 → None
</code></pre>
<p>链表变为：</p>
<pre><code>3 → 2 → None
</code></pre>
<p>返回 rev_head = 3</p>
<hr />
<h4><strong>回到head = 1</strong></h4>
<pre><code>tail = head.next      # 2
tail.next = head      # 2 → 1
head.next = None      # 1 → None
</code></pre>
<p>最终链表：</p>
<pre><code>3 → 2 → 1 → None
</code></pre>
<hr />
<h2><strong>五、为什么始终返回 rev_head？</strong></h2>
<ul>
<li>rev_head <strong>永远指向反转后链表的头节点</strong></li>
<li>它来自递归最深处（原链表尾部）</li>
<li>后续每一层只是在“接节点”，<strong>不改变头指针</strong></li>
</ul>
<p>❌ 错误理解：</p>
<p>“当前 head 是新的头” —— 这是错的</p>
<hr />
<h2><strong>六、为什么必须写 head.next = None？</strong></h2>
<p>如果省略这一句：</p>
<pre><code>tail.next = head
# 没有 head.next = None
</code></pre>
<p>会发生：</p>
<pre><code>1 ↔ 2 ↔ 3
</code></pre>
<p>→ <strong>形成环</strong></p>
<p>✅ 正确作用：</p>
<blockquote>
<p>断开原有正向指针，避免产生环</p>
</blockquote>
<hr />
<h2><strong>七、递归反转链表的「通用模板」</strong></h2>
<p>遇到链表递归题，直接套：</p>
<p>1️⃣ <strong>Base Case</strong></p>
<p>空链表 / 单节点直接返回</p>
<p>2️⃣ <strong>递归调用</strong></p>
<p>先处理 head.next</p>
<p>3️⃣ <strong>局部操作</strong></p>
<p>修改当前节点与后继节点的指针关系</p>
<p>4️⃣ <strong>返回结果</strong></p>
<p>始终返回“最深层”的头节点</p>
<hr />
<h2><strong>八、迭代 vs 递归（建立直觉）</strong></h2>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>思维方式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>迭代</td>
<td>我一步一步往前推</td>
</tr>
<tr>
<td>递归</td>
<td>我相信后面已经反转好了</td>
</tr>
</tbody></table><hr />
<h2><strong>九、🔥 高阶考点：带环链表会发生什么？</strong></h2>
<h3><strong>输入：带环链表</strong></h3>
<pre><code>A → B → C → D → E
        ↑       ↓
        └───────┘
</code></pre>
<hr />
<h3><strong>✅ 结论（面试官标准答案）</strong></h3>
<p><strong>结论 1：不会死循环</strong></p>
<ul>
<li>不会无限递归</li>
<li>不会栈溢出</li>
</ul>
<p><strong>结论 2：最终结果是</strong></p>
<blockquote>
<p><strong>环内被反转，环外保持原样</strong></p>
</blockquote>
<hr />
<h2><strong>十、为什么不会死循环？</strong></h2>
<p>关键不在「有没有环」，而在这里：</p>
<pre><code>head.next = None
</code></pre>
<h3><strong>关键机制</strong></h3>
<ul>
<li>递归下潜时：<strong>不会修改指针</strong></li>
<li>第一次回溯时：</li>
</ul>
<pre><code>head.next = None
</code></pre>
<ul>
<li>👉 <strong>直接剪断环</strong></li>
</ul>
<p>一旦环被破坏：</p>
<ul>
<li>后续递归不会再绕回</li>
<li>递归自然结束</li>
</ul>
<p>📌 加分表述：</p>
<blockquote>
<p>虽然输入是带环链表，但递归反转在回溯阶段会主动破坏环结构，因此不会死循环。</p>
</blockquote>
<hr />
<h2><strong>十一、为什么“环内反转，环外不动”？</strong></h2>
<p>原因只有一句话：</p>
<blockquote>
<p><strong>只有参与回溯的节点，才会执行反转逻辑</strong></p>
</blockquote>
<ul>
<li>递归深入到环内后，才开始回溯</li>
<li>回溯只覆盖环内节点</li>
<li>环外节点的 next 从未被置为 None</li>
<li>因此顺序保持不变</li>
</ul>
<hr />
<h3><strong>最终结构示意</strong></h3>
<p>原始：</p>
<pre><code>A → B → C → D → E
        ↑       ↓
        └───────┘
</code></pre>
<p>结果：</p>
<pre><code>A → B → C ← D ← E
        |
       None
</code></pre>
<hr />
<h2><strong>十二、面试满分回答模板（可直接背）</strong></h2>
<blockquote>
<p>对于带环链表，这个递归反转函数不会死循环。</p>
</blockquote>
<blockquote>
<p>因为在回溯阶段会执行 head.next = None，第一次回溯就会破坏环结构，使递归能够正常终止。</p>
</blockquote>
<blockquote>
<p>最终结果是：环内节点被反转，环外节点保持原有顺序不变。</p>
</blockquote>
]]></content><link href="https://github.com/lihe/MyLeetcode/issues/1"/><category term="链表"/><published>2025-12-24T12:54:45+00:00</published></entry></feed>