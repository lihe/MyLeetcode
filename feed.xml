<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/lihe/MyLeetcode</id><title>RSS feed of lihe's MyLeetcode</title><updated>2025-12-27T05:32:46.179385+00:00</updated><link href="https://github.com/lihe/MyLeetcode"/><link href="https://raw.githubusercontent.com/lihe/MyLeetcode/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/lihe/MyLeetcode/issues/5</id><title>LeetCode 215. 数组中的第K个最大元素</title><updated>2025-12-27T05:32:46.441685+00:00</updated><content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/821137/ji-yu-kuai-pai-de-suo-you-topkwen-ti-jia-ylsd/">https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/821137/ji-yu-kuai-pai-de-suo-you-topkwen-ti-jia-ylsd/</a></p>
<hr />
<h2><strong>一、TopK 问题的本质</strong></h2>
<blockquote>
<p><strong>TopK = Partition（切分） + 选择（不完全排序）</strong></p>
</blockquote>
<p>不是排序问题，</p>
<p>而是 <strong>“把第 k 个元素放到它最终该在的位置”</strong>。</p>
<hr />
<h2><strong>二、面试中 TopK 的 5 种标准问法</strong></h2>
<table>
<thead>
<tr>
<th><strong>问法</strong></th>
<th><strong>本质</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>前 k 小的数</td>
<td>切到索引 k-1</td>
</tr>
<tr>
<td>第 k 小的数</td>
<td>找索引 k-1</td>
</tr>
<tr>
<td>前 k 大的数</td>
<td>切到索引 n-k</td>
</tr>
<tr>
<td>第 k 大的数</td>
<td>找索引 n-k</td>
</tr>
<tr>
<td>只排序前 / 后 k 个</td>
<td>Quickselect + 局部排序</td>
</tr>
</tbody></table><p>👉 <strong>90% 的 TopK 都能映射到这 5 个</strong></p>
<hr />
<h2><strong>三、两种主流解法选型</strong></h2>
<h3><strong>1️⃣ 快选（Quickselect）—— 面试首选</strong></h3>
<ul>
<li>平均时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
<li>原地</li>
<li>不需要完全排序</li>
</ul>
<p>📌 <strong>当 k 不接近 n，或强调效率 → 一定选它</strong></p>
<hr />
<h3><strong>2️⃣ 堆（Heap）—— 稳定保底方案</strong></h3>
<ul>
<li>时间复杂度：O(n log k)</li>
<li>适合 <strong>流式数据 / 超大数据 / 在线 TopK</strong></li>
</ul>
<p>📌 面试官追问时你可以说：</p>
<blockquote>
<p>如果是数据流或内存受限，我会用小根堆 / 大根堆。</p>
</blockquote>
<hr />
<h2><strong>四、Partition（核心中的核心）</strong></h2>
<h3><strong>标准挖坑法</strong></h3>
<pre><code class="language-python">def partition(nums, left, right):
    pivot = nums[left]
    i, j = left, right
    while i &lt; j:
        while i &lt; j and nums[j] &gt;= pivot:
            j -= 1
        nums[i] = nums[j]
        while i &lt; j and nums[i] &lt;= pivot:
            i += 1
        nums[j] = nums[i]
    nums[i] = pivot
    return i
</code></pre>
<p>📌 面试官可能追问：</p>
<ul>
<li>
<p>这是 Hoare 还是 Lomuto？</p>
<p>👉 <strong>Hoare 变体（挖坑法）</strong></p>
</li>
</ul>
<hr />
<h2><strong>五、Quickselect 模板</strong></h2>
<blockquote>
<p><strong>k 一定是 0-based 索引</strong></p>
</blockquote>
<pre><code class="language-python">def quickselect(nums, k, left, right):
    if left &lt; right:
        index = partition(nums, left, right)
        if index == k:
            return
        elif index &lt; k:
            quickselect(nums, k, index + 1, right)
        else:
            quickselect(nums, k, left, index - 1)
</code></pre>
<hr />
<h2><strong>六、TopK 全家桶</strong></h2>
<h3><strong>1️⃣ 前 k 小的数</strong></h3>
<pre><code class="language-python">def topk_smalls(nums, k):
    quickselect(nums, k - 1, 0, len(nums) - 1)
    return nums[:k]
</code></pre>
<hr />
<h3><strong>2️⃣ 第 k 小的数</strong></h3>
<pre><code class="language-python">def kth_small(nums, k):
    quickselect(nums, k - 1, 0, len(nums) - 1)
    return nums[k - 1]
</code></pre>
<hr />
<h3><strong>3️⃣ 前 k 大的数</strong></h3>
<pre><code class="language-python">def topk_larges(nums, k):
    n = len(nums)
    quickselect(nums, n - k, 0, n - 1)
    return nums[n - k:]
</code></pre>
<hr />
<h3><strong>4️⃣ 第 k 大的数</strong></h3>
<pre><code class="language-python">def kth_large(nums, k):
    n = len(nums)
    quickselect(nums, n - k, 0, n - 1)
    return nums[n - k]
</code></pre>
<hr />
<h3><strong>5️⃣ 只排序前 k 个小的数</strong></h3>
<pre><code class="language-python">def topk_sort_left(nums, k):
    quickselect(nums, k - 1, 0, len(nums) - 1)
    quicksort(nums, 0, k - 1)
    return nums
</code></pre>
<hr />
<h3><strong>6️⃣ 只排序后 k 个大的数</strong></h3>
<pre><code class="language-python">def topk_sort_right(nums, k):
    n = len(nums)
    quickselect(nums, n - k, 0, n - 1)
    quicksort(nums, n - k, n - 1)
    return nums
</code></pre>
<hr />
<h2><strong>七、k 的语义速查表</strong></h2>
<table>
<thead>
<tr>
<th><strong>人类语义</strong></th>
<th><strong>Quickselect 用的 k</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>第 k 小</td>
<td>k-1</td>
</tr>
<tr>
<td>前 k 小</td>
<td>k-1</td>
</tr>
<tr>
<td>第 k 大</td>
<td>n-k</td>
</tr>
<tr>
<td>前 k 大</td>
<td>n-k</td>
</tr>
</tbody></table><p>📌 <strong>90% TopK bug 来自这里</strong></p>
<hr />
<h2><strong>八、面试官高频追问 &amp; 标准回答</strong></h2>
<h3><strong>Q1：为什么不用快速排序？</strong></h3>
<blockquote>
<p>因为 TopK 不需要全局有序，只需要第 k 个元素就位。</p>
</blockquote>
<blockquote>
<p>Quickselect 平均时间复杂度是 O(n)，优于排序的 O(n log n)。</p>
</blockquote>
<hr />
<h3><strong>Q2：Quickselect 最坏情况？</strong></h3>
<blockquote>
<p>最坏是 O(n^2)，可以通过随机 pivot 或三数取中优化。</p>
</blockquote>
<hr />
<h3><strong>Q3：什么时候用堆？</strong></h3>
<blockquote>
<p>数据流、k 很小、或者无法一次性加载全部数据时。</p>
</blockquote>
<hr />
<h3><strong>Q4：TopK 会稳定吗？</strong></h3>
<blockquote>
<p>不稳定。Quickselect 和 Heap 都不保证稳定性。</p>
</blockquote>
<hr />
<h2><strong>九、30 秒面试答题心法</strong></h2>
<blockquote>
<p>TopK 本质是选择问题而不是排序问题。</p>
</blockquote>
<blockquote>
<p>我会使用基于 Partition 的 Quickselect，在平均 O(n) 时间内把第 k 个元素放到正确位置。</p>
</blockquote>
<blockquote>
<p>如果需要排序前 / 后 k 个元素，只在局部再做一次排序即可。</p>
</blockquote>
<hr />
<h1><strong>进阶：无序数组找中位数（字节高频题）</strong></h1>
<hr />
<h2><strong>一、题目描述（面试原型）</strong></h2>
<blockquote>
<p>给定一个<strong>无序数组</strong>，在 <strong>不排序整个数组</strong> 的前提下，找到数组的 <strong>中位数</strong>，并分析时间复杂度。</p>
</blockquote>
<hr />
<h2><strong>二、「一句话答案」</strong></h2>
<blockquote>
<p>无序数组找中位数是一个<strong>选择问题</strong>，</p>
</blockquote>
<blockquote>
<p>可以用 <strong>Quickselect（基于 Partition）</strong>，</p>
</blockquote>
<blockquote>
<p>平均时间复杂度是 <strong>O(n)</strong>，空间复杂度 <strong>O(1)</strong>。</p>
</blockquote>
<hr />
<h2><strong>三、中位数 = 第 k 小元素（关键映射）</strong></h2>
<p>设数组长度为 n（0-based 索引）：</p>
<h3><strong>1️⃣ n 为奇数</strong></h3>
<pre><code>中位数 = 第 (n//2 + 1) 小
索引 = n//2
</code></pre>
<h3><strong>2️⃣ n 为偶数（两种情况）</strong></h3>
<table>
<thead>
<tr>
<th><strong>面试要求</strong></th>
<th><strong>处理方式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>任意一个中位数</td>
<td>找第 n//2 小</td>
</tr>
<tr>
<td>数学中位数</td>
<td>找第 n//2 和 n//2 - 1，取平均</td>
</tr>
</tbody></table><hr />
<h2><strong>四、标准解法：Quickselect（核心）</strong></h2>
<h3><strong>1️⃣ 为什么不用排序？</strong></h3>
<blockquote>
<p>排序是 O(n log n)，</p>
</blockquote>
<blockquote>
<p>但中位数只需要一个元素的位置，不需要全局有序。</p>
</blockquote>
<p>这是面试官<strong>一定会追问</strong>的点。</p>
<hr />
<h3><strong>2️⃣ Quickselect 思想</strong></h3>
<blockquote>
<p>每一次 partition，都能确定一个元素的最终位置</p>
</blockquote>
<blockquote>
<p>如果这个位置正好是中位数索引，直接返回</p>
</blockquote>
<blockquote>
<p>否则只递归一边</p>
</blockquote>
<hr />
<h2><strong>五、代码模板</strong></h2>
<h3><strong>Partition（挖坑法）</strong></h3>
<pre><code class="language-python">def partition(nums, left, right):
    pivot = nums[left]
    i, j = left, right
    while i &lt; j:
        while i &lt; j and nums[j] &gt;= pivot:
            j -= 1
        nums[i] = nums[j]
        while i &lt; j and nums[i] &lt;= pivot:
            i += 1
        nums[j] = nums[i]
    nums[i] = pivot
    return i
</code></pre>
<hr />
<h3><strong>Quickselect</strong></h3>
<pre><code class="language-python">def quickselect(nums, k, left, right):
    if left &lt; right:
        index = partition(nums, left, right)
        if index == k:
            return
        elif index &lt; k:
            quickselect(nums, k, index + 1, right)
        else:
            quickselect(nums, k, left, index - 1)
</code></pre>
<hr />
<h3><strong>找中位数（奇数长度）</strong></h3>
<pre><code class="language-python">def find_median(nums):
    n = len(nums)
    k = n // 2
    quickselect(nums, k, 0, n - 1)
    return nums[k]
</code></pre>
<hr />
<h2><strong>六、时间复杂度分析</strong></h2>
<h3><strong>平均时间复杂度：✅ O(n)</strong></h3>
<ul>
<li>每次 partition 是 O(n)</li>
<li>但只递归一半</li>
<li>所以是线性期望</li>
</ul>
<hr />
<h3><strong>最坏时间复杂度：⚠️ O(n²)</strong></h3>
<ul>
<li>pivot 每次都选到极端值（如已排序数组）</li>
</ul>
<hr />
<h3><strong>优化一句话</strong></h3>
<blockquote>
<p>可以通过 <strong>随机选 pivot</strong> 或 <strong>三数取中</strong>，</p>
</blockquote>
<blockquote>
<p>将最坏情况概率极大降低。</p>
</blockquote>
<hr />
<h2><strong>七、面试官可能的追问 &amp; 标准回答</strong></h2>
<h3><strong>Q1：如果是数据流，怎么找中位数？</strong></h3>
<blockquote>
<p>使用两个堆：</p>
</blockquote>
<ul>
<li>
<blockquote>
<p>一个大根堆存左半部分</p>
</blockquote>
</li>
<li>
<blockquote>
<p>一个小根堆存右半部分</p>
</blockquote>
<blockquote>
<p>动态维护平衡</p>
</blockquote>
</li>
</ul>
<hr />
<h3><strong>Q2：为什么 Quickselect 不稳定？</strong></h3>
<blockquote>
<p>因为 Partition 会交换相等元素的相对顺序，</p>
</blockquote>
<blockquote>
<p>不保证稳定性。</p>
</blockquote>
<hr />
<h3><strong>Q3：你会不会用堆来做？</strong></h3>
<blockquote>
<p>会，但堆是 O(n log n) 或 O(n log k)，在静态数组中不如 Quickselect 高效。</p>
</blockquote>
<hr />
<h2><strong>八、30 秒「字节标准回答模板」（可直接背）</strong></h2>
<blockquote>
<p>无序数组找中位数可以转化为选择问题。</p>
</blockquote>
<blockquote>
<p>我会使用基于 Partition 的 Quickselect 算法，在平均 O(n) 时间内把中位数放到正确位置。</p>
</blockquote>
<blockquote>
<p>相比排序的 O(n log n)，效率更高。</p>
</blockquote>
<blockquote>
<p>最坏情况是 O(n²)，可以通过随机 pivot 优化。</p>
</blockquote>
<hr />
]]></content><link href="https://github.com/lihe/MyLeetcode/issues/5"/><published>2025-12-25T14:54:28+00:00</published></entry><entry><id>https://github.com/lihe/MyLeetcode/issues/1</id><title>LeetCode 206 反转链表</title><updated>2025-12-27T05:32:46.589037+00:00</updated><content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a></p>
<h2><strong>一、题目回顾</strong></h2>
<p><strong>问题</strong></p>
<p>给定单链表头节点 head，反转链表并返回反转后的头节点。</p>
<hr />
<h2><strong>二、两种标准解法概览</strong></h2>
<h3><strong>1️⃣ 迭代法（首插法 / 三指针）</strong></h3>
<pre><code class="language-python">class Solution:
    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        pre = None
        cur = head
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre
</code></pre>
<p><strong>核心思想</strong></p>
<p>不断把当前节点 cur 插到新链表头部 pre 前。</p>
<hr />
<h3><strong>2️⃣ 递归法（重点）</strong></h3>
<pre><code class="language-python">class Solution:
    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        if head is None or head.next is None:
            return head
        
        rev_head = self.reverseList(head.next)
        tail = head.next
        tail.next = head
        head.next = None
        return rev_head
</code></pre>
<hr />
<h2><strong>三、递归反转链表的本质理解</strong></h2>
<h3><strong>递归一句话定义</strong></h3>
<blockquote>
<p><strong>我不反转整个链表，只负责把“当前节点”接到“已经反转好的后半段”后面。</strong></p>
</blockquote>
<hr />
<h2><strong>四、递归执行的完整过程（示例）</strong></h2>
<p>链表：</p>
<pre><code>1 → 2 → 3 → None
</code></pre>
<p>调用：</p>
<pre><code>reverseList(1)
</code></pre>
<hr />
<h3><strong>1️⃣ 递归下潜（只做调用，不反转）</strong></h3>
<pre><code>reverse(1)
 → reverse(2)
   → reverse(3)
</code></pre>
<p>在 head = 3 时触发 base case：</p>
<pre><code>if head.next is None:
    return head
</code></pre>
<p>返回节点 3</p>
<hr />
<h3><strong>2️⃣ 回溯阶段（真正发生反转）</strong></h3>
<h4><strong>回到head = 2</strong></h4>
<pre><code>tail = head.next      # 3
tail.next = head      # 3 → 2
head.next = None      # 2 → None
</code></pre>
<p>链表变为：</p>
<pre><code>3 → 2 → None
</code></pre>
<p>返回 rev_head = 3</p>
<hr />
<h4><strong>回到head = 1</strong></h4>
<pre><code>tail = head.next      # 2
tail.next = head      # 2 → 1
head.next = None      # 1 → None
</code></pre>
<p>最终链表：</p>
<pre><code>3 → 2 → 1 → None
</code></pre>
<hr />
<h2><strong>五、为什么始终返回 rev_head？</strong></h2>
<ul>
<li>rev_head <strong>永远指向反转后链表的头节点</strong></li>
<li>它来自递归最深处（原链表尾部）</li>
<li>后续每一层只是在“接节点”，<strong>不改变头指针</strong></li>
</ul>
<p>❌ 错误理解：</p>
<p>“当前 head 是新的头” —— 这是错的</p>
<hr />
<h2><strong>六、为什么必须写 head.next = None？</strong></h2>
<p>如果省略这一句：</p>
<pre><code>tail.next = head
# 没有 head.next = None
</code></pre>
<p>会发生：</p>
<pre><code>1 ↔ 2 ↔ 3
</code></pre>
<p>→ <strong>形成环</strong></p>
<p>✅ 正确作用：</p>
<blockquote>
<p>断开原有正向指针，避免产生环</p>
</blockquote>
<hr />
<h2><strong>七、递归反转链表的「通用模板」</strong></h2>
<p>遇到链表递归题，直接套：</p>
<p>1️⃣ <strong>Base Case</strong></p>
<p>空链表 / 单节点直接返回</p>
<p>2️⃣ <strong>递归调用</strong></p>
<p>先处理 head.next</p>
<p>3️⃣ <strong>局部操作</strong></p>
<p>修改当前节点与后继节点的指针关系</p>
<p>4️⃣ <strong>返回结果</strong></p>
<p>始终返回“最深层”的头节点</p>
<hr />
<h2><strong>八、迭代 vs 递归（建立直觉）</strong></h2>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>思维方式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>迭代</td>
<td>我一步一步往前推</td>
</tr>
<tr>
<td>递归</td>
<td>我相信后面已经反转好了</td>
</tr>
</tbody></table><hr />
<h2><strong>九、🔥 高阶考点：带环链表会发生什么？</strong></h2>
<h3><strong>输入：带环链表</strong></h3>
<pre><code>A → B → C → D → E
        ↑       ↓
        └───────┘
</code></pre>
<hr />
<h3><strong>✅ 结论（面试官标准答案）</strong></h3>
<p><strong>结论 1：不会死循环</strong></p>
<ul>
<li>不会无限递归</li>
<li>不会栈溢出</li>
</ul>
<p><strong>结论 2：最终结果是</strong></p>
<blockquote>
<p><strong>环内被反转，环外保持原样</strong></p>
</blockquote>
<hr />
<h2><strong>十、为什么不会死循环？</strong></h2>
<p>关键不在「有没有环」，而在这里：</p>
<pre><code>head.next = None
</code></pre>
<h3><strong>关键机制</strong></h3>
<ul>
<li>递归下潜时：<strong>不会修改指针</strong></li>
<li>第一次回溯时：</li>
</ul>
<pre><code>head.next = None
</code></pre>
<ul>
<li>👉 <strong>直接剪断环</strong></li>
</ul>
<p>一旦环被破坏：</p>
<ul>
<li>后续递归不会再绕回</li>
<li>递归自然结束</li>
</ul>
<p>📌 加分表述：</p>
<blockquote>
<p>虽然输入是带环链表，但递归反转在回溯阶段会主动破坏环结构，因此不会死循环。</p>
</blockquote>
<hr />
<h2><strong>十一、为什么“环内反转，环外不动”？</strong></h2>
<p>原因只有一句话：</p>
<blockquote>
<p><strong>只有参与回溯的节点，才会执行反转逻辑</strong></p>
</blockquote>
<ul>
<li>递归深入到环内后，才开始回溯</li>
<li>回溯只覆盖环内节点</li>
<li>环外节点的 next 从未被置为 None</li>
<li>因此顺序保持不变</li>
</ul>
<hr />
<h3><strong>最终结构示意</strong></h3>
<p>原始：</p>
<pre><code>A → B → C → D → E
        ↑       ↓
        └───────┘
</code></pre>
<p>结果：</p>
<pre><code>A → B → C ← D ← E
        |
       None
</code></pre>
<hr />
<h2><strong>十二、面试满分回答模板（可直接背）</strong></h2>
<blockquote>
<p>对于带环链表，这个递归反转函数不会死循环。</p>
</blockquote>
<blockquote>
<p>因为在回溯阶段会执行 head.next = None，第一次回溯就会破坏环结构，使递归能够正常终止。</p>
</blockquote>
<blockquote>
<p>最终结果是：环内节点被反转，环外节点保持原有顺序不变。</p>
</blockquote>
]]></content><link href="https://github.com/lihe/MyLeetcode/issues/1"/><category term="链表"/><published>2025-12-24T12:54:45+00:00</published></entry></feed>